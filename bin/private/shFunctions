# ---------------------------------------------------------
# Load BenjaVision Catalyst config (layered)
# Precedence (highest → lowest):
#   1. Environment variables (already set in ENV)
#   2. Local overrides in CWD (*.bvc)
#   3. Config root ($BVC_CONF_DIR, default: ./conf relative to CWD)
#      └─ $BVC_CONF_DIR/bvc/bvc_defaults
#   4. Bundled defaults (../conf/bvc/bvc_defaults relative to SCRIPT_DIR)
#   5. Hard-coded safety net (below)
# ---------------------------------------------------------
load_bvc_config() {
  : "${SCRIPT_DIR:?SCRIPT_DIR must be set before calling load_bvc_config}"

  # 2) Local overrides in CWD (*.bvc)
  set +f
  for f in "$PWD"/*.bvc; do
    [ -r "$f" ] && . "$f"
  done
  set -f

  # 3) Resolve BVC_CONF_DIR (default: ./conf relative to CWD)
  : "${BVC_CONF_DIR:=conf}"
  case "$BVC_CONF_DIR" in
    /*) conf_root="$BVC_CONF_DIR" ;;
    ~)  conf_root="$HOME" ;;
    ~/*) conf_root="$HOME/${BVC_CONF_DIR#~/}" ;;
    *)  conf_root="$PWD/$BVC_CONF_DIR" ;;
  esac
  
   # set CONF_DIR for all scripts
  CONF_DIR="$conf_root"

  if [ -r "$conf_root/bvc/bvc_defaults" ]; then
    . "$conf_root/bvc/bvc_defaults"
  fi

  # 4) Bundled defaults (shipped with toolkit)
  bundled_conf="${SCRIPT_DIR}/../conf/bvc/bvc_defaults"
  [ -r "$bundled_conf" ] && . "$bundled_conf"

  # 5) Safety net (only if still unset after all layers)
  : "${DEFAULT_REGISTRY:=bvc}"
  : "${GSDEVKIT_STONES_DIR:=stones}"
  : "${ROWAN_PROJECTS_HOME:=git}"
  : "${GEMSTONE_VERSION:=3.7.4.3}"
  : "${GEMSTONE_STONE_NAME:=bvc_dev}"
  : "${GT_INSTALL_DIR:=BVCDevKit}"
  : "${GT_APP_NAME:=BVCDevKit}"
  : "${GT_BUILD_SCRIPTS_DIR:=gt/build_scripts}"
  : "${J4P_INSTALL_DIR:=Jadeite4Pharo}"
  : "${J4P_PHARO_VERSION:=120}"
  : "${PHARO_INSTALL_DIR:=Pharo}"
  : "${PHARO_VERSION:=130}"
}

# Resolve a config file with user override (CONF_DIR) first, then bundled fallback.
conf_resolve() {
  : "${CONF_DIR:?CONF_DIR must be set (call load_bvc_config first)}"
  rel="$1"
  if [ -r "${CONF_DIR}/${rel}" ]; then
    printf '%s\n' "${CONF_DIR}/${rel}"
  elif [ -r "${SCRIPT_DIR}/../conf/${rel}" ]; then
    printf '%s\n' "${SCRIPT_DIR}/../conf/${rel}"
  else
    error_banner "Config not found in CONF_DIR or bundled: ${rel}"
    exit 1
  fi
}

#===============================================
# Path helpers
#===============================================

abs_from_cwd() {
  p="$1"
  case "$p" in
    '')  printf %s "$PWD" ;;
    /*)  printf %s "$p" ;;
    ~)   printf %s "$HOME" ;;
    ~/*) printf %s "$HOME/${p#~/}" ;;
    *)   printf %s "$PWD/$p" ;;
  esac
}

path_from_script() {
  : "${SCRIPT_DIR:?}"
  p="$1"
  case "$p" in
    /*|~|~/*) abs_from_cwd "$p" ;;
    *)        printf %s "${SCRIPT_DIR}/$p" | sed 's:/*$::' ;;
  esac
}

#===============================================
# Feedback & Utilities (POSIX sh)
#===============================================

# Check that a tool exists. eg. need git
need() { command -v "$1" >/dev/null 2>&1 || { error_banner "Missing required tool: $1"; exit 1; }; }

_should_color() {
	# Explicit opt-out per https://no-color.org/
	[ -n "${NO_COLOR-}" ] && return 1
	# Explicit opt-in override
	[ "${BVC_FORCE_COLOR-}" = "1" ] && return 0
	# TTY + not a "dumb" term
	[ -t 2 ] || return 1
	[ "${TERM-}" = "dumb" ] && return 1
	return 0
}

if _should_color; then

ANSI_RESET="$(printf '\033[0m')"

# Darker slate-grey blue for banners / info
ANSI_BLUE="$(printf '\033[38;5;67m')"

# Calmer green, closer to natural foliage
ANSI_GREEN="$(printf '\033[38;5;101m')"

# Warm grey-beige for warnings
ANSI_YELLOW="$(printf '\033[38;5;144m')"

# Subtle brick red for errors
ANSI_RED="$(printf '\033[38;5;131m')"

else
	ANSI_RED=''; ANSI_GREEN=''; ANSI_YELLOW=''; ANSI_BLUE=''; ANSI_RESET=''
fi

# Script name (portable)
prog_basename() { bn="$1"; bn=${bn##*/}; printf %s "$bn"; }


exit_1_banner() {
	msg="$1"
	printf "%s%s :: %s%s\n" "${ANSI_RED}" "$msg" "$(prog_basename "$0")" "${ANSI_RESET}" 1>&2
	exit 1
}

exit_0_banner() {
	msg="$1"
	printf "%s%s :: %s%s\n" "${ANSI_GREEN}" "$msg" "$(prog_basename "$0")" "${ANSI_RESET}" 1>&2
	exit 0
}

start_banner() {
	theArgs="$*"
	printf "%s===========================%s\n" "${ANSI_BLUE}" "${ANSI_RESET}" 1>&2
	printf "%sBenjaVision Catalyst DevKit%s\n" "${ANSI_BLUE}" "${ANSI_RESET}" 1>&2
	printf "%s                    script: %s %s%s\n" "${ANSI_BLUE}" "$(prog_basename "$0")" "${theArgs}" "${ANSI_RESET}" 1>&2
	printf "%s                      path: %s%s\n" "${ANSI_BLUE}" "$0" "${ANSI_RESET}" 1>&2
	printf "%s          Send feedback to: jupiter@benjavision.com%s\n" "${ANSI_BLUE}" "${ANSI_RESET}" 1>&2
	printf "%s===========================%s\n" "${ANSI_BLUE}" "${ANSI_RESET}" 1>&2
}

information_banner() { printf "%s%s%s\n" "${ANSI_BLUE}" "$1" "${ANSI_RESET}" 1>&2; }
warning_banner()     { printf "%s%s%s\n" "${ANSI_YELLOW}" "$1" "${ANSI_RESET}" 1>&2; }
error_banner()     { printf "%s%s%s\n" "${ANSI_RED}" "$1" "${ANSI_RESET}" 1>&2; }

# Error/INT traps (POSIX)
interrupted() {
	lineno="$1"
	printf "%s^C detected (line %s) :: %s%s\n" "${ANSI_YELLOW}" "${lineno}" "$(prog_basename "$0")" "${ANSI_RESET}" 1>&2
	exit 1
}

error() {
	lineno="$1"
	exit_1_banner "Error on or near line ${lineno}"
}

# Cursor control (best-effort)
_have_tput=false
command -v tput >/dev/null 2>&1 && _have_tput=true

#===============================================
# Spinner
#===============================================
spinner_pid=

spinner_start() {
	local LC_CTYPE=C
	local spin='⣾⣽⣻⢿⡿⣟⣯⣷'
	local charwidth=3
	local i=0
	tput civis # cursor invisible

	{ while : ; do i=$(((i + $charwidth) % ${#spin})) ; printf "%s" "$1 ${spin:$i:$charwidth}" ; printf "\r" ; sleep 0.1 ; done  & } 2>/dev/null
	spinner_pid=$!
}

spinner_stop() {
	{ kill -9 $spinner_pid && wait; } 2>/dev/null
	set -m
	echo -en "\033[2K\r"
	tput cnorm # reset cursor
}
trap spinner_stop EXIT

#===============================================
# Architecture
#===============================================
platform=
architecture=

set_platform_and_architecture() {
	if [[ "$OSTYPE" == "linux-gnu"* ]]; then
		arch_name="$(uname -m)"
		platform="Linux"
		if [ "${arch_name}" = "x86_64" ]; then
			architecture="Linux64"
		elif [ "${arch_name}" = "aarch64" ]; then
			architecture="LinuxArm64"
		else
			warning_banner "$arch_name architecture is unsupported."
			exit 1
		fi
	elif [[ "$OSTYPE" == "darwin"* ]]; then
		platform="Mac"
		arch_name="$(uname -m)"
		is_m1=false
		if [ "${arch_name}" = "x86_64" ]; then
			if [ "$(sysctl -in sysctl.proc_translated)" = "1" ]; then
				is_m1=true
			fi
		elif [ "${arch_name}" = "arm64" ]; then
			is_m1=true
		fi
			
		if [[ "$is_m1" == true ]]; then
			architecture="OSXM1"
		else
			architecture="OSX64"
		fi
	elif [[ "$OSTYPE" == "cygwin" || "$OSTYPE" == "msys" || "$OSTYPE" == "win32" ]]; then
		platform="Win"
		architecture="Win64"
		#TODO: WinArm64
	else
		warning_banner "$OSTYPE is unsupported."
		exit 1
	fi
}

# Global traps installed by callers (don’t exit here)
setup_traps() {
	trap 'interrupted ${LINENO}' INT
	trap 'spinner_stop; error ${LINENO}' ERR
	# Let callers decide what to print on EXIT
}
